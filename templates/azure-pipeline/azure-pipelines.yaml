trigger:
  branches:
    include:
    - main
    - develop
  paths:
    exclude:
    - README.md
    - docs/**

pr:
  branches:
    include:
    - main
    - develop

variables:
  # Build variables
  buildConfiguration: 'Release'
  vmImage: 'ubuntu-latest'

  # Docker variables
  dockerRegistry: 'myacr.azurecr.io'
  imageName: 'myapp'
  imageTag: '$(Build.BuildId)'

  # Kubernetes variables
  k8sNamespace: 'myapp'

stages:
- stage: Build
  displayName: 'Build and Test'
  jobs:
  - job: BuildJob
    displayName: 'Build Application'
    pool:
      vmImage: $(vmImage)
    steps:
    - task: NodeTool@0
      displayName: 'Install Node.js'
      inputs:
        versionSpec: '18.x'

    - task: Cache@2
      displayName: 'Cache npm packages'
      inputs:
        key: 'npm | "$(Agent.OS)" | package-lock.json'
        path: '$(Pipeline.Workspace)/.npm'
        restoreKeys: |
          npm | "$(Agent.OS)"

    - script: |
        npm ci --cache $(Pipeline.Workspace)/.npm
      displayName: 'Install Dependencies'

    - script: |
        npm run lint
        npm run build
      displayName: 'Lint and Build'

    - script: |
        npm run test -- --coverage
      displayName: 'Run Tests'

    - task: PublishTestResults@2
      displayName: 'Publish Test Results'
      condition: succeededOrFailed()
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/test-results.xml'
        mergeTestResults: true

    - task: PublishCodeCoverageResults@1
      displayName: 'Publish Code Coverage'
      condition: succeededOrFailed()
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: '$(System.DefaultWorkingDirectory)/coverage/cobertura-coverage.xml'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Build Artifacts'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: 'drop'

- stage: Docker
  displayName: 'Build Docker Image'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: DockerBuild
    displayName: 'Build and Push Docker Image'
    pool:
      vmImage: $(vmImage)
    steps:
    - task: Docker@2
      displayName: 'Build Docker Image'
      inputs:
        containerRegistry: 'MyACRServiceConnection'
        repository: '$(imageName)'
        command: 'build'
        Dockerfile: '**/Dockerfile'
        tags: |
          $(imageTag)
          latest

    - task: Docker@2
      displayName: 'Push Docker Image'
      inputs:
        containerRegistry: 'MyACRServiceConnection'
        repository: '$(imageName)'
        command: 'push'
        tags: |
          $(imageTag)
          latest

    - task: Docker@2
      displayName: 'Run Security Scan'
      continueOnError: true
      inputs:
        command: 'run'
        arguments: '--rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy image $(dockerRegistry)/$(imageName):$(imageTag)'

- stage: DeployDev
  displayName: 'Deploy to Development'
  dependsOn: Docker
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
  jobs:
  - deployment: DeployDev
    displayName: 'Deploy to Dev Environment'
    pool:
      vmImage: $(vmImage)
    environment: 'development'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: KubernetesManifest@0
            displayName: 'Create/Update ConfigMap'
            inputs:
              action: 'deploy'
              kubernetesServiceConnection: 'k8s-dev'
              namespace: '$(k8sNamespace)-dev'
              manifests: |
                k8s/configmap.yaml

          - task: KubernetesManifest@0
            displayName: 'Deploy Application'
            inputs:
              action: 'deploy'
              kubernetesServiceConnection: 'k8s-dev'
              namespace: '$(k8sNamespace)-dev'
              manifests: |
                k8s/deployment.yaml
                k8s/service.yaml
              containers: |
                $(dockerRegistry)/$(imageName):$(imageTag)

          - task: Kubernetes@1
            displayName: 'Verify Deployment'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: 'k8s-dev'
              namespace: '$(k8sNamespace)-dev'
              command: 'get'
              arguments: 'pods'

- stage: DeployProd
  displayName: 'Deploy to Production'
  dependsOn: Docker
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - deployment: DeployProd
    displayName: 'Deploy to Production Environment'
    pool:
      vmImage: $(vmImage)
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: KubernetesManifest@0
            displayName: 'Create/Update ConfigMap'
            inputs:
              action: 'deploy'
              kubernetesServiceConnection: 'k8s-prod'
              namespace: '$(k8sNamespace)-prod'
              manifests: |
                k8s/configmap.yaml

          - task: KubernetesManifest@0
            displayName: 'Deploy Application'
            inputs:
              action: 'deploy'
              kubernetesServiceConnection: 'k8s-prod'
              namespace: '$(k8sNamespace)-prod'
              manifests: |
                k8s/deployment.yaml
                k8s/service.yaml
                k8s/ingress.yaml
              containers: |
                $(dockerRegistry)/$(imageName):$(imageTag)

          - task: Kubernetes@1
            displayName: 'Verify Deployment'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: 'k8s-prod'
              namespace: '$(k8sNamespace)-prod'
              command: 'rollout'
              arguments: 'status deployment/myapp'

          - task: Kubernetes@1
            displayName: 'Check Pod Status'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: 'k8s-prod'
              namespace: '$(k8sNamespace)-prod'
              command: 'get'
              arguments: 'pods -l app=myapp'
